<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>CloudhopperBuilder.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">reporting</a> &gt; <a href="../index.html" class="el_bundle">ogham-sms-cloudhopper</a> &gt; <a href="index.source.html" class="el_package">fr.sii.ogham.sms.builder.cloudhopper</a> &gt; <span class="el_source">CloudhopperBuilder.java</span></div><h1>CloudhopperBuilder.java</h1><pre class="source lang-java linenums">package fr.sii.ogham.sms.builder.cloudhopper;

import static com.cloudhopper.commons.charset.CharsetUtil.NAME_GSM;
import static com.cloudhopper.smpp.SmppBindType.TRANSMITTER;
import static fr.sii.ogham.sms.builder.cloudhopper.InterfaceVersion.VERSION_3_4;

import java.util.function.Consumer;
import java.util.function.Supplier;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.cloudhopper.commons.charset.Charset;
import com.cloudhopper.smpp.SmppBindType;
import com.cloudhopper.smpp.SmppClient;
import com.cloudhopper.smpp.SmppConstants;
import com.cloudhopper.smpp.SmppSessionConfiguration;
import com.cloudhopper.smpp.SmppSessionHandler;
import com.cloudhopper.smpp.impl.DefaultSmppClient;
import com.cloudhopper.smpp.impl.DefaultSmppSessionHandler;
import com.cloudhopper.smpp.pdu.Pdu;
import com.cloudhopper.smpp.pdu.SubmitSm;
import com.cloudhopper.smpp.ssl.SslConfiguration;
import com.cloudhopper.smpp.type.Address;
import com.cloudhopper.smpp.type.LoggingOptions;

import fr.sii.ogham.core.async.ThreadSleepAwaiter;
import fr.sii.ogham.core.builder.Builder;
import fr.sii.ogham.core.builder.MessagingBuilder;
import fr.sii.ogham.core.builder.configuration.ConfigurationValueBuilder;
import fr.sii.ogham.core.builder.configuration.ConfigurationValueBuilderHelper;
import fr.sii.ogham.core.builder.configurer.Configurer;
import fr.sii.ogham.core.builder.context.BuildContext;
import fr.sii.ogham.core.builder.context.DefaultBuildContext;
import fr.sii.ogham.core.fluent.AbstractParent;
import fr.sii.ogham.core.retry.RetryExecutor;
import fr.sii.ogham.core.retry.SimpleRetryExecutor;
import fr.sii.ogham.sms.builder.SmsBuilder;
import fr.sii.ogham.sms.builder.cloudhopper.UserDataBuilder.UserDataPropValues;
import fr.sii.ogham.sms.encoder.Encoder;
import fr.sii.ogham.sms.message.Sms;
import fr.sii.ogham.sms.message.addressing.translator.CompositePhoneNumberTranslator;
import fr.sii.ogham.sms.message.addressing.translator.DefaultHandler;
import fr.sii.ogham.sms.message.addressing.translator.PhoneNumberTranslator;
import fr.sii.ogham.sms.sender.impl.CloudhopperSMPPSender;
import fr.sii.ogham.sms.sender.impl.cloudhopper.CloudhopperOptions;
import fr.sii.ogham.sms.sender.impl.cloudhopper.encoder.CloudhopperCharsetSupportingEncoder;
import fr.sii.ogham.sms.sender.impl.cloudhopper.encoder.NamedCharset;
import fr.sii.ogham.sms.sender.impl.cloudhopper.preparator.CharsetMapToCharacterEncodingGroupDataCodingProvider;
import fr.sii.ogham.sms.sender.impl.cloudhopper.preparator.DataCodingProvider;
import fr.sii.ogham.sms.sender.impl.cloudhopper.preparator.MessagePreparator;
import fr.sii.ogham.sms.sender.impl.cloudhopper.preparator.ShortMessagePreparator;
import fr.sii.ogham.sms.sender.impl.cloudhopper.preparator.TlvMessagePayloadMessagePreparator;
import fr.sii.ogham.sms.splitter.GsmMessageSplitter;
import fr.sii.ogham.sms.splitter.MessageSplitter;
import fr.sii.ogham.sms.splitter.NoSplitMessageSplitter;
import fr.sii.ogham.sms.splitter.ReferenceNumberGenerator;

/**
 * Configures Cloudhopper:
 * 
 * &lt;ul&gt;
 * &lt;li&gt;SMPP protocol parameters (host, port, systemId, password,
 * version...)&lt;/li&gt;
 * &lt;li&gt;Session management (name, bind, timeouts, retry...)&lt;/li&gt;
 * &lt;li&gt;SSL configuration&lt;/li&gt;
 * &lt;li&gt;Logging options&lt;/li&gt;
 * &lt;/ul&gt;
 * 
 * &lt;p&gt;
 * To send {@link Sms} using Cloudhopper, you need to register this builder into
 * a {@link MessagingBuilder} like this:
 * 
 * &lt;pre&gt;
 * &lt;code&gt;
 * MessagingBuilder msgBuilder = ...
 * msgBuilder.sms()
 *    .sender(CloudhopperBuilder.class)    // registers the builder and accesses to that builder for configuring it
 * &lt;/code&gt;
 * &lt;/pre&gt;
 * 
 * Once the builder is registered, sending sms through Cloudhopper requires at
 * least host of the SMPP server. You can define it using:
 * 
 * &lt;pre&gt;
 * &lt;code&gt;
 * msgBuilder.sms()
 *    .sender(CloudhopperBuilder.class)    // registers the builder and accesses to that builder for configuring it
 *       .host(&quot;localhost&quot;)
 * &lt;/code&gt;
 * &lt;/pre&gt;
 * 
 * Or you can also use property keys (using interpolation):
 * 
 * &lt;pre&gt;
 * &lt;code&gt;
 * msgBuilder
 * .environment()
 *    .properties()
 *       .set(&quot;custom.property.for.host&quot;, &quot;localhost&quot;)
 *       .and()
 *    .and()
 * .sms()
 *    .sender(CloudhopperBuilder.class)    // registers the builder and accesses to that builder for configuring it
 *       .host()
 *         .properties(&quot;${custom.property.for.host}&quot;)
 * &lt;/code&gt;
 * &lt;/pre&gt;
 * 
 * You can do the same with port of the SMPP server.
 * 
 * 
 * &lt;p&gt;
 * SMPP server may require authentication. In most cases, authentication is done
 * using system_id/password. You can use this builder to quickly provide your
 * system_id and password:
 * 
 * &lt;pre&gt;
 * &lt;code&gt;
 * .sender(CloudhopperBuilder.class)
 *        .systemId(&quot;foo&quot;)
 *        .password(&quot;bar&quot;)
 * &lt;/code&gt;
 * &lt;/pre&gt;
 * 
 * 
 * @author Aurélien Baudet
 */
public class CloudhopperBuilder extends AbstractParent&lt;SmsBuilder&gt; implements Builder&lt;CloudhopperSMPPSender&gt; {
	private static final long DEFAULT_UNBIND_TIMEOUT = 5000L;

	private static final long DEFAULT_RESPONSE_TIMEOUT = 5000L;

<span class="fc" id="L134">	private static final Logger LOG = LoggerFactory.getLogger(CloudhopperBuilder.class);</span>

	private final ReadableEncoderBuilder sharedEncoderBuilder;
	private BuildContext buildContext;
	private final ConfigurationValueBuilderHelper&lt;CloudhopperBuilder, String&gt; systemIdValueBuilder;
	private final ConfigurationValueBuilderHelper&lt;CloudhopperBuilder, String&gt; passwordValueBuilder;
	private final ConfigurationValueBuilderHelper&lt;CloudhopperBuilder, String&gt; hostValueBuilder;
	private final ConfigurationValueBuilderHelper&lt;CloudhopperBuilder, Integer&gt; portValueBuilder;
	private final ConfigurationValueBuilderHelper&lt;CloudhopperBuilder, String&gt; systemTypeValueBuilder;
	private final ConfigurationValueBuilderHelper&lt;CloudhopperBuilder, InterfaceVersion&gt; interfaceVersionValueBuilder;
	private final ConfigurationValueBuilderHelper&lt;CloudhopperBuilder, SmppBindType&gt; bindTypeValueBuilder;
	private SessionBuilder sessionBuilder;
	private SmppSessionConfiguration sessionConfiguration;
	private Address addressRange;
	private SslBuilder sslBuilder;
	private LoggingBuilder loggingBuilder;
	private SmppClientSupplier clientSupplier;
	private SmppSessionHandlerSupplier smppSessionHandler;
	private MessageSplitterBuilder messageSplitterBuilder;
	private EncoderBuilder encoderBuilder;
	private UserDataBuilder userDataBuilder;
	private DataCodingSchemeBuilder dataCodingBuilder;
	private MessagePreparator preparator;

	/**
	 * Default constructor when using without all Ogham work.
	 * 
	 * &lt;strong&gt;WARNING: use is only if you know what you are doing !&lt;/strong&gt;
	 */
	public CloudhopperBuilder() {
<span class="fc" id="L164">		this(null, new DefaultBuildContext());</span>
<span class="fc" id="L165">	}</span>

	/**
	 * Constructor that is called when using Ogham builder:
	 * 
	 * &lt;pre&gt;
	 * MessagingBuilder msgBuilder = ...
	 * msgBuilder
	 * .sms()
	 *    .sender(CloudhopperBuilder.class)
	 * &lt;/pre&gt;
	 * 
	 * @param parent
	 *            the parent builder instance for fluent chaining
	 * @param buildContext
	 *            for registering instances and property evaluation
	 */
	public CloudhopperBuilder(SmsBuilder parent, BuildContext buildContext) {
<span class="fc" id="L183">		super(parent);</span>
<span class="fc" id="L184">		this.buildContext = buildContext;</span>
<span class="fc" id="L185">		sharedEncoderBuilder = new ReadableEncoderBuilder(buildContext);</span>
<span class="fc" id="L186">		systemIdValueBuilder = new ConfigurationValueBuilderHelper&lt;&gt;(this, String.class, buildContext);</span>
<span class="fc" id="L187">		passwordValueBuilder = new ConfigurationValueBuilderHelper&lt;&gt;(this, String.class, buildContext);</span>
<span class="fc" id="L188">		hostValueBuilder = new ConfigurationValueBuilderHelper&lt;&gt;(this, String.class, buildContext);</span>
<span class="fc" id="L189">		portValueBuilder = new ConfigurationValueBuilderHelper&lt;&gt;(this, Integer.class, buildContext);</span>
<span class="fc" id="L190">		interfaceVersionValueBuilder = new ConfigurationValueBuilderHelper&lt;&gt;(this, InterfaceVersion.class, buildContext);</span>
<span class="fc" id="L191">		systemTypeValueBuilder = new ConfigurationValueBuilderHelper&lt;&gt;(this, String.class, buildContext);</span>
<span class="fc" id="L192">		bindTypeValueBuilder = new ConfigurationValueBuilderHelper&lt;&gt;(this, SmppBindType.class, buildContext);</span>
<span class="fc" id="L193">	}</span>

	/**
	 * The system_id parameter is used to identify an ESME ( External Short
	 * Message Entity) or an SMSC (Short Message Service Centre) at bind time.
	 * An ESME system_id identifies the ESME or ESME agent to the SMSC. The SMSC
	 * system_id provides an identification of the SMSC to the ESME.
	 * 
	 * &lt;p&gt;
	 * The value set using this method takes precedence over any property and
	 * default value configured using {@link #systemId()}.
	 * 
	 * &lt;pre&gt;
	 * .systemId(&quot;my-system-id&quot;)
	 * .systemId()
	 *   .properties(&quot;${custom.property.high-priority}&quot;, &quot;${custom.property.low-priority}&quot;)
	 *   .defaultValue(&quot;default-system-id&quot;)
	 * &lt;/pre&gt;
	 * 
	 * &lt;pre&gt;
	 * .systemId(&quot;my-system-id&quot;)
	 * .systemId()
	 *   .properties(&quot;${custom.property.high-priority}&quot;, &quot;${custom.property.low-priority}&quot;)
	 *   .defaultValue(&quot;default-system-id&quot;)
	 * &lt;/pre&gt;
	 * 
	 * In both cases, {@code systemId(&quot;my-system-id&quot;)} is used.
	 * 
	 * &lt;p&gt;
	 * If this method is called several times, only the last value is used.
	 * 
	 * &lt;p&gt;
	 * If {@code null} value is set, it is like not setting a value at all. The
	 * property/default value configuration is applied.
	 * 
	 * @param systemId
	 *            the system_id value
	 * @return this instance for fluent chaining
	 */
	public CloudhopperBuilder systemId(String systemId) {
<span class="nc" id="L233">		systemIdValueBuilder.setValue(systemId);</span>
<span class="nc" id="L234">		return this;</span>
	}

	/**
	 * The system_id parameter is used to identify an ESME ( External Short
	 * Message Entity) or an SMSC (Short Message Service Centre) at bind time.
	 * An ESME system_id identifies the ESME or ESME agent to the SMSC. The SMSC
	 * system_id provides an identification of the SMSC to the ESME.
	 * 
	 * &lt;p&gt;
	 * This method is mainly used by {@link Configurer}s to register some
	 * property keys and/or a default value. The aim is to let developer be able
	 * to externalize its configuration (using system properties, configuration
	 * file or anything else). If the developer doesn't configure any value for
	 * the registered properties, the default value is used (if set).
	 * 
	 * &lt;pre&gt;
	 * .systemId()
	 *   .properties(&quot;${custom.property.high-priority}&quot;, &quot;${custom.property.low-priority}&quot;)
	 *   .defaultValue(&quot;default-system-id&quot;)
	 * &lt;/pre&gt;
	 * 
	 * &lt;p&gt;
	 * Non-null value set using {@link #systemId(String)} takes precedence over
	 * property values and default value.
	 * 
	 * &lt;pre&gt;
	 * .systemId(&quot;my-system-id&quot;)
	 * .systemId()
	 *   .properties(&quot;${custom.property.high-priority}&quot;, &quot;${custom.property.low-priority}&quot;)
	 *   .defaultValue(&quot;default-system-id&quot;)
	 * &lt;/pre&gt;
	 * 
	 * The value {@code &quot;my-system-id&quot;} is used regardless of the value of the
	 * properties and default value.
	 * 
	 * &lt;p&gt;
	 * See {@link ConfigurationValueBuilder} for more information.
	 * 
	 * 
	 * @return the builder to configure property keys/default value
	 */
	public ConfigurationValueBuilder&lt;CloudhopperBuilder, String&gt; systemId() {
<span class="fc" id="L277">		return systemIdValueBuilder;</span>
	}

	/**
	 * The system_type parameter is used to categorize the type of ESME that is
	 * binding to the SMSC. Examples include “VMS” (voice mail system) and “OTA”
	 * (over-the-air activation system). Specification of the system_type is
	 * optional - some SMSC’s may not require ESME’s to provide this detail. In
	 * this case, the ESME can set the system_type to NULL. The system_type
	 * (optional) may be used to categorize the system, e.g., “EMAIL”, “WWW”,
	 * etc.
	 * 
	 * &lt;p&gt;
	 * The value set using this method takes precedence over any property and
	 * default value configured using {@link #systemType()}.
	 * 
	 * &lt;pre&gt;
	 * .systemType(&quot;my-system-type&quot;)
	 * .systemType()
	 *   .properties(&quot;${custom.property.high-priority}&quot;, &quot;${custom.property.low-priority}&quot;)
	 *   .defaultValue(&quot;default-system-type&quot;)
	 * &lt;/pre&gt;
	 * 
	 * &lt;pre&gt;
	 * .systemType(&quot;my-system-type&quot;)
	 * .systemType()
	 *   .properties(&quot;${custom.property.high-priority}&quot;, &quot;${custom.property.low-priority}&quot;)
	 *   .defaultValue(&quot;default-system-type&quot;)
	 * &lt;/pre&gt;
	 * 
	 * In both cases, {@code systemType(&quot;my-system-type&quot;)} is used.
	 * 
	 * &lt;p&gt;
	 * If this method is called several times, only the last value is used.
	 * 
	 * &lt;p&gt;
	 * If {@code null} value is set, it is like not setting a value at all. The
	 * property/default value configuration is applied.
	 * 
	 * @param systemType
	 *            the system type value
	 * @return this instance for fluent chaining
	 */
	public CloudhopperBuilder systemType(String systemType) {
<span class="nc" id="L321">		systemTypeValueBuilder.setValue(systemType);</span>
<span class="nc" id="L322">		return this;</span>
	}

	/**
	 * The system_type parameter is used to categorize the type of ESME that is
	 * binding to the SMSC. Examples include “VMS” (voice mail system) and “OTA”
	 * (over-the-air activation system). Specification of the system_type is
	 * optional - some SMSC’s may not require ESME’s to provide this detail. In
	 * this case, the ESME can set the system_type to NULL. The system_type
	 * (optional) may be used to categorize the system, e.g., “EMAIL”, “WWW”,
	 * etc.
	 * 
	 * &lt;p&gt;
	 * This method is mainly used by {@link Configurer}s to register some
	 * property keys and/or a default value. The aim is to let developer be able
	 * to externalize its configuration (using system properties, configuration
	 * file or anything else). If the developer doesn't configure any value for
	 * the registered properties, the default value is used (if set).
	 * 
	 * &lt;pre&gt;
	 * .systemType()
	 *   .properties(&quot;${custom.property.high-priority}&quot;, &quot;${custom.property.low-priority}&quot;)
	 *   .defaultValue(&quot;defaut-system-type&quot;)
	 * &lt;/pre&gt;
	 * 
	 * &lt;p&gt;
	 * Non-null value set using {@link #systemType(String)} takes precedence
	 * over property values and default value.
	 * 
	 * &lt;pre&gt;
	 * .systemType(&quot;my-system-type&quot;)
	 * .systemType()
	 *   .properties(&quot;${custom.property.high-priority}&quot;, &quot;${custom.property.low-priority}&quot;)
	 *   .defaultValue(&quot;defaut-system-type&quot;)
	 * &lt;/pre&gt;
	 * 
	 * The value {@code &quot;my-system-type&quot;} is used regardless of the value of the
	 * properties and default value.
	 * 
	 * &lt;p&gt;
	 * See {@link ConfigurationValueBuilder} for more information.
	 * 
	 * 
	 * @return the builder to configure property keys/default value
	 */
	public ConfigurationValueBuilder&lt;CloudhopperBuilder, String&gt; systemType() {
<span class="fc" id="L368">		return systemTypeValueBuilder;</span>
	}

	/**
	 * The password parameter is used by the SMSC to authenticate the identity
	 * of the binding ESME. The Service Provider may require ESME’s to provide a
	 * password when binding to the SMSC. This password is normally issued by
	 * the SMSC system administrator. The password parameter may also be used by
	 * the ESME to authenticate the identity of the binding SMSC (e.g. in the
	 * case of the outbind operation).
	 * 
	 * &lt;p&gt;
	 * The value set using this method takes precedence over any property and
	 * default value configured using {@link #password()}.
	 * 
	 * &lt;pre&gt;
	 * .password(&quot;my-password&quot;)
	 * .password()
	 *   .properties(&quot;${custom.property.high-priority}&quot;, &quot;${custom.property.low-priority}&quot;)
	 *   .defaultValue(&quot;default-password&quot;)
	 * &lt;/pre&gt;
	 * 
	 * &lt;pre&gt;
	 * .password(&quot;my-password&quot;)
	 * .password()
	 *   .properties(&quot;${custom.property.high-priority}&quot;, &quot;${custom.property.low-priority}&quot;)
	 *   .defaultValue(&quot;default-password&quot;)
	 * &lt;/pre&gt;
	 * 
	 * In both cases, {@code password(&quot;my-password&quot;)} is used.
	 * 
	 * &lt;p&gt;
	 * If this method is called several times, only the last value is used.
	 * 
	 * &lt;p&gt;
	 * If {@code null} value is set, it is like not setting a value at all. The
	 * property/default value configuration is applied.
	 * 
	 * @param password
	 *            the password used to authenticate
	 * @return this instance for fluent chaining
	 */
	public CloudhopperBuilder password(String password) {
<span class="nc" id="L411">		passwordValueBuilder.setValue(password);</span>
<span class="nc" id="L412">		return this;</span>
	}

	/**
	 * The password parameter is used by the SMSC to authenticate the identity
	 * of the binding ESME. The Service Provider may require ESME’s to provide a
	 * password when binding to the SMSC. This password is normally issued by
	 * the SMSC system administrator. The password parameter may also be used by
	 * the ESME to authenticate the identity of the binding SMSC (e.g. in the
	 * case of the outbind operation).
	 * 
	 * &lt;p&gt;
	 * This method is mainly used by {@link Configurer}s to register some
	 * property keys and/or a default value. The aim is to let developer be able
	 * to externalize its configuration (using system properties, configuration
	 * file or anything else). If the developer doesn't configure any value for
	 * the registered properties, the default value is used (if set).
	 * 
	 * &lt;pre&gt;
	 * .password()
	 *   .properties(&quot;${custom.property.high-priority}&quot;, &quot;${custom.property.low-priority}&quot;)
	 *   .defaultValue(&quot;default-password&quot;)
	 * &lt;/pre&gt;
	 * 
	 * &lt;p&gt;
	 * Non-null value set using {@link #password(String)} takes precedence over
	 * property values and default value.
	 * 
	 * &lt;pre&gt;
	 * .password(&quot;my-password&quot;)
	 * .password()
	 *   .properties(&quot;${custom.property.high-priority}&quot;, &quot;${custom.property.low-priority}&quot;)
	 *   .defaultValue(&quot;default-password&quot;)
	 * &lt;/pre&gt;
	 * 
	 * The value {@code &quot;my-password&quot;} is used regardless of the value of the
	 * properties and default value.
	 * 
	 * &lt;p&gt;
	 * See {@link ConfigurationValueBuilder} for more information.
	 * 
	 * 
	 * @return the builder to configure property keys/default value
	 */
	public ConfigurationValueBuilder&lt;CloudhopperBuilder, String&gt; password() {
<span class="fc" id="L457">		return passwordValueBuilder;</span>
	}

	/**
	 * The SMPP server host (IP or address).
	 * 
	 * &lt;p&gt;
	 * The value set using this method takes precedence over any property and
	 * default value configured using {@link #host()}.
	 * 
	 * &lt;pre&gt;
	 * .host(&quot;localhost&quot;)
	 * .host()
	 *   .properties(&quot;${custom.property.high-priority}&quot;, &quot;${custom.property.low-priority}&quot;)
	 *   .defaultValue(&quot;default-host&quot;)
	 * &lt;/pre&gt;
	 * 
	 * &lt;pre&gt;
	 * .host(&quot;localhost&quot;)
	 * .host()
	 *   .properties(&quot;${custom.property.high-priority}&quot;, &quot;${custom.property.low-priority}&quot;)
	 *   .defaultValue(&quot;default-host&quot;)
	 * &lt;/pre&gt;
	 * 
	 * In both cases, {@code host(&quot;localhost&quot;)} is used.
	 * 
	 * &lt;p&gt;
	 * If this method is called several times, only the last value is used.
	 * 
	 * &lt;p&gt;
	 * If {@code null} value is set, it is like not setting a value at all. The
	 * property/default value configuration is applied.
	 * 
	 * @param host
	 *            the host address
	 * @return this instance for fluent chaining
	 */
	public CloudhopperBuilder host(String host) {
<span class="fc" id="L495">		hostValueBuilder.setValue(host);</span>
<span class="fc" id="L496">		return this;</span>
	}

	/**
	 * The SMPP server host (IP or address).
	 * 
	 * &lt;p&gt;
	 * This method is mainly used by {@link Configurer}s to register some
	 * property keys and/or a default value. The aim is to let developer be able
	 * to externalize its configuration (using system properties, configuration
	 * file or anything else). If the developer doesn't configure any value for
	 * the registered properties, the default value is used (if set).
	 * 
	 * &lt;pre&gt;
	 * .host()
	 *   .properties(&quot;${custom.property.high-priority}&quot;, &quot;${custom.property.low-priority}&quot;)
	 *   .defaultValue(&quot;default-host&quot;)
	 * &lt;/pre&gt;
	 * 
	 * &lt;p&gt;
	 * Non-null value set using {@link #host(String)} takes precedence over
	 * property values and default value.
	 * 
	 * &lt;pre&gt;
	 * .host(&quot;localhost&quot;)
	 * .host()
	 *   .properties(&quot;${custom.property.high-priority}&quot;, &quot;${custom.property.low-priority}&quot;)
	 *   .defaultValue(&quot;default-host&quot;)
	 * &lt;/pre&gt;
	 * 
	 * The value {@code &quot;localhost&quot;} is used regardless of the value of the
	 * properties and default value.
	 * 
	 * &lt;p&gt;
	 * See {@link ConfigurationValueBuilder} for more information.
	 * 
	 * 
	 * @return the builder to configure property keys/default value
	 */
	public ConfigurationValueBuilder&lt;CloudhopperBuilder, String&gt; host() {
<span class="fc" id="L536">		return hostValueBuilder;</span>
	}

	/**
	 * Set the SMPP server port.
	 * 
	 * &lt;p&gt;
	 * The value set using this method takes precedence over any property and
	 * default value configured using {@link #port()}.
	 * 
	 * &lt;pre&gt;
	 * .port(2775)
	 * .port()
	 *   .properties(&quot;${custom.property.high-priority}&quot;, &quot;${custom.property.low-priority}&quot;)
	 *   .defaultValue(1775)
	 * &lt;/pre&gt;
	 * 
	 * &lt;pre&gt;
	 * .port(2775)
	 * .port()
	 *   .properties(&quot;${custom.property.high-priority}&quot;, &quot;${custom.property.low-priority}&quot;)
	 *   .defaultValue(1775)
	 * &lt;/pre&gt;
	 * 
	 * In both cases, {@code port(2775)} is used.
	 * 
	 * &lt;p&gt;
	 * If this method is called several times, only the last value is used.
	 * 
	 * &lt;p&gt;
	 * If {@code null} value is set, it is like not setting a value at all. The
	 * property/default value configuration is applied.
	 * 
	 * @param port
	 *            the SMPP server port
	 * @return this instance for fluent chaining
	 */
	public CloudhopperBuilder port(Integer port) {
<span class="fc" id="L574">		portValueBuilder.setValue(port);</span>
<span class="fc" id="L575">		return this;</span>
	}

	/**
	 * Set the SMPP server port.
	 * 
	 * &lt;p&gt;
	 * This method is mainly used by {@link Configurer}s to register some
	 * property keys and/or a default value. The aim is to let developer be able
	 * to externalize its configuration (using system properties, configuration
	 * file or anything else). If the developer doesn't configure any value for
	 * the registered properties, the default value is used (if set).
	 * 
	 * &lt;pre&gt;
	 * .port()
	 *   .properties(&quot;${custom.property.high-priority}&quot;, &quot;${custom.property.low-priority}&quot;)
	 *   .defaultValue(1775)
	 * &lt;/pre&gt;
	 * 
	 * &lt;p&gt;
	 * Non-null value set using {@link #port(Integer)} takes precedence over
	 * property values and default value.
	 * 
	 * &lt;pre&gt;
	 * .port(2775)
	 * .port()
	 *   .properties(&quot;${custom.property.high-priority}&quot;, &quot;${custom.property.low-priority}&quot;)
	 *   .defaultValue(1775)
	 * &lt;/pre&gt;
	 * 
	 * The value {@code 2775} is used regardless of the value of the properties
	 * and default value.
	 * 
	 * &lt;p&gt;
	 * See {@link ConfigurationValueBuilder} for more information.
	 * 
	 * 
	 * @return the builder to configure property keys/default value
	 */
	public ConfigurationValueBuilder&lt;CloudhopperBuilder, Integer&gt; port() {
<span class="fc" id="L615">		return portValueBuilder;</span>
	}

	/**
	 * The SMPP protocol version (one of {@link InterfaceVersion#VERSION_3_3},
	 * {@link InterfaceVersion#VERSION_3_4},
	 * {@link InterfaceVersion#VERSION_5_0}).
	 * 
	 * &lt;p&gt;
	 * The value set using this method takes precedence over any property and
	 * default value configured using {@link #interfaceVersion()}.
	 * 
	 * &lt;pre&gt;
	 * .interfaceVersion(InterfaceVersion.VERSION_5_0)
	 * .interfaceVersion()
	 *   .properties(&quot;${custom.property.high-priority}&quot;, &quot;${custom.property.low-priority}&quot;)
	 *   .defaultValue(InterfaceVersion.VERSION_3_4)
	 * &lt;/pre&gt;
	 * 
	 * &lt;pre&gt;
	 * .interfaceVersion(InterfaceVersion.VERSION_5_0)
	 * .interfaceVersion()
	 *   .properties(&quot;${custom.property.high-priority}&quot;, &quot;${custom.property.low-priority}&quot;)
	 *   .defaultValue(InterfaceVersion.VERSION_3_4)
	 * &lt;/pre&gt;
	 * 
	 * In both cases, {@code interfaceVersion(InterfaceVersion.VERSION_5_0)} is
	 * used.
	 * 
	 * &lt;p&gt;
	 * If this method is called several times, only the last value is used.
	 * 
	 * &lt;p&gt;
	 * If {@code null} value is set, it is like not setting a value at all. The
	 * property/default value configuration is applied.
	 * 
	 * @param version
	 *            the version of the SMPP protocol
	 * @return this instance for fluent chaining
	 */
	public CloudhopperBuilder interfaceVersion(InterfaceVersion version) {
<span class="nc" id="L656">		interfaceVersionValueBuilder.setValue(version);</span>
<span class="nc" id="L657">		return this;</span>
	}

	/**
	 * The SMPP protocol version (one of {@link SmppConstants#VERSION_3_3},
	 * {@link SmppConstants#VERSION_3_4}, {@link SmppConstants#VERSION_5_0}).
	 * 
	 * &lt;p&gt;
	 * The value set using this method takes precedence over any property and
	 * default value configured using {@link #interfaceVersion()}.
	 * 
	 * &lt;pre&gt;
	 * .interfaceVersion(SmppConstants.VERSION_5_0)
	 * .interfaceVersion()
	 *   .properties(&quot;${custom.property.high-priority}&quot;, &quot;${custom.property.low-priority}&quot;)
	 *   .defaultValue(SmppConstants.VERSION_3_4)
	 * &lt;/pre&gt;
	 * 
	 * &lt;pre&gt;
	 * .interfaceVersion(SmppConstants.VERSION_5_0)
	 * .interfaceVersion()
	 *   .properties(&quot;${custom.property.high-priority}&quot;, &quot;${custom.property.low-priority}&quot;)
	 *   .defaultValue(SmppConstants.VERSION_3_4)
	 * &lt;/pre&gt;
	 * 
	 * In both cases, {@code interfaceVersion(SmppConstants.VERSION_5_0)} is
	 * used.
	 * 
	 * &lt;p&gt;
	 * If this method is called several times, only the last value is used.
	 * 
	 * &lt;p&gt;
	 * If {@code null} value is set, it is like not setting a value at all. The
	 * property/default value configuration is applied.
	 * 
	 * @param version
	 *            the version of the SMPP protocol
	 * @return this instance for fluent chaining
	 */
	public CloudhopperBuilder interfaceVersion(Byte version) {
<span class="nc" id="L697">		interfaceVersionValueBuilder.setValue(InterfaceVersion.fromValue(version));</span>
<span class="nc" id="L698">		return this;</span>
	}

	/**
	 * The SMPP protocol version (one of {@link InterfaceVersion#VERSION_3_3},
	 * {@link InterfaceVersion#VERSION_3_4},
	 * {@link InterfaceVersion#VERSION_5_0}).
	 * 
	 * 
	 * &lt;p&gt;
	 * This method is mainly used by {@link Configurer}s to register some
	 * property keys and/or a default value. The aim is to let developer be able
	 * to externalize its configuration (using system properties, configuration
	 * file or anything else). If the developer doesn't configure any value for
	 * the registered properties, the default value is used (if set).
	 * 
	 * &lt;pre&gt;
	 * .interfaceVersion()
	 *   .properties(&quot;${custom.property.high-priority}&quot;, &quot;${custom.property.low-priority}&quot;)
	 *   .defaultValue(InterfaceVersion.VERSION_3_4)
	 * &lt;/pre&gt;
	 * 
	 * &lt;p&gt;
	 * Non-null value set using {@link #interfaceVersion(InterfaceVersion)}
	 * takes precedence over property values and default value.
	 * 
	 * &lt;pre&gt;
	 * .interfaceVersion(InterfaceVersion.VERSION_5_0)
	 * .interfaceVersion()
	 *   .properties(&quot;${custom.property.high-priority}&quot;, &quot;${custom.property.low-priority}&quot;)
	 *   .defaultValue(InterfaceVersion.VERSION_3_4)
	 * &lt;/pre&gt;
	 * 
	 * The value {@code InterfaceVersion.VERSION_5_0} is used regardless of the
	 * value of the properties and default value.
	 * 
	 * &lt;p&gt;
	 * See {@link ConfigurationValueBuilder} for more information.
	 * 
	 * 
	 * @return the builder to configure property keys/default value
	 */
	public ConfigurationValueBuilder&lt;CloudhopperBuilder, InterfaceVersion&gt; interfaceVersion() {
<span class="fc" id="L741">		return interfaceVersionValueBuilder;</span>
	}

	/**
	 * The bind command type (see {@link SmppBindType}).
	 * 
	 * &lt;p&gt;
	 * The value set using this method takes precedence over any property and
	 * default value configured using {@link #bindType()}.
	 * 
	 * &lt;pre&gt;
	 * .bindType(SmppBindType.TRANSCEIVER)
	 * .bindType()
	 *   .properties(&quot;${custom.property.high-priority}&quot;, &quot;${custom.property.low-priority}&quot;)
	 *   .defaultValue(SmppBindType.RECEIVER)
	 * &lt;/pre&gt;
	 * 
	 * &lt;pre&gt;
	 * .bindType(SmppBindType.TRANSCEIVER)
	 * .bindType()
	 *   .properties(&quot;${custom.property.high-priority}&quot;, &quot;${custom.property.low-priority}&quot;)
	 *   .defaultValue(SmppBindType.RECEIVER)
	 * &lt;/pre&gt;
	 * 
	 * In both cases, {@code bindType(SmppBindType.TRANSCEIVER)} is used.
	 * 
	 * &lt;p&gt;
	 * If this method is called several times, only the last value is used.
	 * 
	 * &lt;p&gt;
	 * If {@code null} value is set, it is like not setting a value at all. The
	 * property/default value configuration is applied.
	 * 
	 * @param bindType
	 *            the bind type
	 * @return this instance for fluent chaining
	 */
	public CloudhopperBuilder bindType(SmppBindType bindType) {
<span class="nc" id="L779">		bindTypeValueBuilder.setValue(bindType);</span>
<span class="nc" id="L780">		return this;</span>
	}

	/**
	 * The bind command type (see {@link SmppBindType}).
	 * 
	 * &lt;p&gt;
	 * This method is mainly used by {@link Configurer}s to register some
	 * property keys and/or a default value. The aim is to let developer be able
	 * to externalize its configuration (using system properties, configuration
	 * file or anything else). If the developer doesn't configure any value for
	 * the registered properties, the default value is used (if set).
	 * 
	 * &lt;pre&gt;
	 * .bindType()
	 *   .properties(&quot;${custom.property.high-priority}&quot;, &quot;${custom.property.low-priority}&quot;)
	 *   .defaultValue(SmppBindType.RECEIVER)
	 * &lt;/pre&gt;
	 * 
	 * &lt;p&gt;
	 * Non-null value set using {@link #bindType(SmppBindType)} takes precedence
	 * over property values and default value.
	 * 
	 * &lt;pre&gt;
	 * .bindType(SmppBindType.TRANSCEIVER)
	 * .bindType()
	 *   .properties(&quot;${custom.property.high-priority}&quot;, &quot;${custom.property.low-priority}&quot;)
	 *   .defaultValue(SmppBindType.RECEIVER)
	 * &lt;/pre&gt;
	 * 
	 * The value {@code SmppBindType.TRANSCEIVER} is used regardless of the
	 * value of the properties and default value.
	 * 
	 * &lt;p&gt;
	 * See {@link ConfigurationValueBuilder} for more information.
	 * 
	 * 
	 * @return the builder to configure property keys/default value
	 */
	public ConfigurationValueBuilder&lt;CloudhopperBuilder, SmppBindType&gt; bindType() {
<span class="fc" id="L820">		return bindTypeValueBuilder;</span>
	}

	/**
	 * Configures how Cloudhopper will encode SMS messages. Charsets defined by
	 * the SMPP protocol may be different from NIO charsets.
	 * 
	 * &lt;p&gt;
	 * The encoder will be used to transform Java {@link String} into a byte
	 * array that is understandable by SMPP servers.
	 * 
	 * &lt;p&gt;
	 * This builder configures encoders for both messages that are split and
	 * message that are not split.
	 * 
	 * &lt;p&gt;
	 * This builder allows to configure:
	 * &lt;ul&gt;
	 * &lt;li&gt;Enable/disable the standard GSM encoders (GSM 7-bit, GSM 8-bit and
	 * UCS-2) as defined in
	 * &lt;a href=&quot;https://en.wikipedia.org/wiki/GSM_03.38&quot;&gt;GSM 03.38
	 * specification&lt;/a&gt;. It also allows to define different priority order&lt;/li&gt;
	 * &lt;li&gt;Enable/disable automatic guessing of encoding (based on previously
	 * registered priorities).&lt;/li&gt;
	 * &lt;li&gt;Define a fallback encoder based on {@link Charset}&lt;/li&gt;
	 * &lt;li&gt;Provide custom {@link Encoder}s&lt;/li&gt;
	 * &lt;/ul&gt;
	 * 
	 * &lt;pre&gt;
	 * {@code
	 * .encoder()
	 *    .gsm7()
	 *      .properties(&quot;${ogham.sms.cloudhopper.encoder.gsm7bit-packed.priority}&quot;, &quot;${ogham.sms.smpp.encoder.gsm7bit-packed.priority}&quot;)
	 *      .defaultValue(100000)
	 *      .and()
	 *    .gsm8()
	 *      .properties(&quot;${ogham.sms.cloudhopper.encoder.gsm8bit.priority}&quot;, &quot;${ogham.sms.smpp.encoder.gsm8bit.priority}&quot;)
	 *      .defaultValue(99000)
	 *      .and()
	 *    .ucs2()
	 *      .properties(&quot;${ogham.sms.cloudhopper.encoder.ucs2.priority}&quot;, &quot;${ogham.sms.smpp.encoder.ucs2.priority}&quot;)
	 *      .defaultValue(98000)
	 *      .and()
	 *    .autoGuess()
	 *      .properties(&quot;${ogham.sms.cloudhopper.encoder.auto-guess.enable}&quot;, &quot;${ogham.sms.smpp.encoder.auto-guess.enable}&quot;)
	 *      .defaultValue(true)
	 *      .and()
	 *    .fallback()
	 *      .properties(&quot;${ogham.sms.cloudhopper.encoder.default-charset}&quot;, &quot;${ogham.sms.smpp.encoder.default-charset}&quot;)
	 *      .defaultValue(CharsetUtil.NAME_GSM)
	 *      .and()
	 *    .customEncoder(new MyCustomEncoder(), 50000)
	 * }
	 * &lt;/pre&gt;
	 * 
	 * @return the builder to configure the encoder
	 */
	public EncoderBuilder encoder() {
<span class="fc bfc" id="L878" title="All 2 branches covered.">		if (encoderBuilder == null) {</span>
<span class="fc" id="L879">			encoderBuilder = new EncoderBuilder(this, buildContext);</span>
<span class="fc" id="L880">			sharedEncoderBuilder.update(encoderBuilder);</span>
		}
<span class="fc" id="L882">		return encoderBuilder;</span>
	}

	/**
	 * Configures how Cloudhopper will split messages.
	 * 
	 * &lt;p&gt;
	 * The splitter will check if the whole message can fit in a single segment.
	 * If not the splitter will split the whole message in several segments with
	 * a header to indicate splitting information such as number of segments,
	 * reference number and current segment number.
	 * 
	 * &lt;p&gt;
	 * {@link Encoder} configured using {@link #encoder()} is used to encode
	 * each segment.
	 * 
	 * &lt;p&gt;
	 * If automatic guessing of best standard encoder is enabled for
	 * {@link Encoder} (using {@code encoder().autoGuess(true)}), and message
	 * splitting is enabled, then standard message splitting is configured such
	 * as:
	 * &lt;ul&gt;
	 * &lt;li&gt;If GSM 7-bit encoder is enabled, {@link GsmMessageSplitter} is used
	 * to split messages that support this encoding. If whole message can fit in
	 * a single segment of 160 characters. Longer message is split into segments
	 * of either 153 characters or 152 characters (depending on reference number
	 * generation, see {@link ReferenceNumberGenerator})&lt;/li&gt;
	 * &lt;li&gt;If GSM 8-bit encoder is enabled, {@link GsmMessageSplitter} is used
	 * to split messages that support this encoding. If whole message can fit in
	 * a single segment of 140 characters. Longer message is split into segments
	 * of either 134 characters or 133 characters (depending on reference number
	 * generation, see {@link ReferenceNumberGenerator})&lt;/li&gt;
	 * &lt;li&gt;If UCS-2 encoder is enabled, {@link GsmMessageSplitter} is used to
	 * split messages that support this encoding. If whole message can fit in a
	 * single segment of 70 characters. Longer message is split into segments of
	 * either 67 characters or 66 characters (depending on reference number
	 * generation, see {@link ReferenceNumberGenerator})&lt;/li&gt;
	 * &lt;/ul&gt;
	 * 
	 * Each registered splitter uses the same priority as associated
	 * {@link Encoder}.
	 * 
	 * If you don't want standard message splitting based on supported
	 * {@link Encoder}s, you can either disable message splitting or provide a
	 * custom splitter with higher priority.
	 * 
	 * &lt;p&gt;
	 * This builder allows to configure:
	 * &lt;ul&gt;
	 * &lt;li&gt;Enable/disable message splitting&lt;/li&gt;
	 * &lt;li&gt;Provide a custom split strategy&lt;/li&gt;
	 * &lt;li&gt;Choose strategy for reference number generation&lt;/li&gt;
	 * &lt;/ul&gt;
	 * 
	 * &lt;p&gt;
	 * Examples of usage:
	 * 
	 * &lt;pre&gt;
	 * {@code
	 * .splitter()
	 *   .enable()
	 *     .properties(&quot;${ogham.sms.cloudhopper.split.enable}&quot;, &quot;${ogham.sms.smpp.split.enable}&quot;, &quot;${ogham.sms.split.enable}&quot;)
	 *     .defaultValue(true)
	 *     .and()
	 *   .customSplitter(new MyCustomSplitter(), 100000)
	 *   .referenceNumber()
	 *     .random()
	 *     .random(new Random())
	 *     .generator(new MyCustomReferenceNumberGenerator())
	 * }
	 * &lt;/pre&gt;
	 * 
	 * @return the builder to configure message splitting
	 */
	public MessageSplitterBuilder splitter() {
<span class="fc bfc" id="L957" title="All 2 branches covered.">		if (messageSplitterBuilder == null) {</span>
<span class="fc" id="L958">			messageSplitterBuilder = new MessageSplitterBuilder(this, buildContext, sharedEncoderBuilder);</span>
		}
<span class="fc" id="L960">		return messageSplitterBuilder;</span>
	}

	/**
	 * Configures Cloudhopper session management (timeouts, retry, session
	 * name...).
	 * 
	 * @return the builder to configure the session management
	 */
	public SessionBuilder session() {
<span class="fc bfc" id="L970" title="All 2 branches covered.">		if (sessionBuilder == null) {</span>
<span class="fc" id="L971">			sessionBuilder = new SessionBuilder(this, buildContext);</span>
		}
<span class="fc" id="L973">		return sessionBuilder;</span>
	}

	/**
	 * Overrides any previously defined Cloudhopper parameters to use the
	 * provided session.
	 * 
	 * &lt;p&gt;
	 * If this method is called several times, only the last session is used.
	 * 
	 * @param session
	 *            the Cloudhopper session to use
	 * @return this instance for fluent chaining
	 */
	public CloudhopperBuilder session(SmppSessionConfiguration session) {
<span class="fc" id="L988">		this.sessionConfiguration = session;</span>
<span class="fc" id="L989">		return this;</span>
	}

	/**
	 * The address_range parameter is used in the bind_receiver and
	 * bind_transceiver command to specify a set of SME addresses serviced by
	 * the ESME client. A single SME address may also be specified in the
	 * address_range parameter. UNIX Regular Expression notation should be used
	 * to specify a range of addresses. Messages addressed to any destination in
	 * this range shall be routed to the ESME.
	 * 
	 * Default to {@code null}.
	 * 
	 * Note: For IP addresses, it is only possible to specify a single IP
	 * address. A range of IP addresses are not allowed. IP version 6.0 is not
	 * currently supported in this version of the protocol.
	 * 
	 * Note: It is likely that the addr_range field is not supported or
	 * deliberately ignored on most Message Centres. The reason for this is that
	 * most carriers will not allow an ESME control the message routing as this
	 * can carry the risk of mis-routing messages. In such circumstances, the
	 * ESME will be requested to set the field to NULL.
	 * 
	 * @param range
	 *            the address range
	 * @return this instance for fluent chaining
	 */
	public CloudhopperBuilder addressRange(Address range) {
<span class="nc" id="L1017">		this.addressRange = range;</span>
<span class="nc" id="L1018">		return this;</span>
	}

	/**
	 * Enable or disable SSL configuration and configure how SSL is handled.
	 * 
	 * See &lt;a href=
	 * &quot;https://github.com/fizzed/cloudhopper-smpp/blob/master/SSL.md&quot;&gt;How to
	 * use SSL with cloudhopper-smpp&lt;/a&gt;
	 * 
	 * @return the builder to configure SSL
	 */
	public SslBuilder ssl() {
<span class="nc bnc" id="L1031" title="All 2 branches missed.">		if (sslBuilder == null) {</span>
<span class="nc" id="L1032">			sslBuilder = new SslBuilder(this, buildContext);</span>
		}
<span class="nc" id="L1034">		return sslBuilder;</span>
	}

	/**
	 * Configure logs:
	 * &lt;ul&gt;
	 * &lt;li&gt;Enable/disable log of {@link Pdu}s&lt;/li&gt;
	 * &lt;li&gt;Enable/disable log of bytes&lt;/li&gt;
	 * &lt;/ul&gt;
	 * 
	 * @return the builder to enable/disable some logs
	 */
	public LoggingBuilder logging() {
<span class="nc bnc" id="L1047" title="All 2 branches missed.">		if (loggingBuilder == null) {</span>
<span class="nc" id="L1048">			loggingBuilder = new LoggingBuilder(this);</span>
		}
<span class="nc" id="L1050">		return loggingBuilder;</span>
	}

	/**
	 * By default, {@link CloudhopperSMPPSender} uses {@link DefaultSmppClient}
	 * client. This option provides a way to use another {@link SmppClient}.
	 * 
	 * @param supplier
	 *            an implementation that provides an instance of a
	 *            {@link SmppClient}
	 * @return this instance for fluent chaining
	 */
	public CloudhopperBuilder clientSupplier(SmppClientSupplier supplier) {
<span class="fc" id="L1063">		this.clientSupplier = supplier;</span>
<span class="fc" id="L1064">		return this;</span>
	}

	/**
	 * By default, {@link CloudhopperSMPPSender} uses
	 * {@link DefaultSmppSessionHandler}. This option provides a way to use
	 * another {@link SmppSessionHandler}.
	 * 
	 * @param supplier
	 *            an implementation that provides an instance of a
	 *            {@link SmppSessionHandler}
	 * @return this instance for fluent chaining
	 */
	public CloudhopperBuilder smppSessionHandlerSupplier(SmppSessionHandlerSupplier supplier) {
<span class="fc" id="L1078">		this.smppSessionHandler = supplier;</span>
<span class="fc" id="L1079">		return this;</span>
	}

	/**
	 * {@link Sms} message is converted to {@link SubmitSm}(s) using a
	 * {@link MessagePreparator}.
	 * 
	 * &lt;p&gt;
	 * You can provide a custom {@link MessagePreparator} instance if the
	 * default behavior doesn't fit your needs.
	 * &lt;/p&gt;
	 * 
	 * &lt;p&gt;
	 * If a custom {@link MessagePreparator} is set, any other preparator (using
	 * {@link #userData()}) is not used.
	 * &lt;/p&gt;
	 * 
	 * &lt;p&gt;
	 * If this method is called several times, only the last value is used.
	 * &lt;/p&gt;
	 * 
	 * &lt;p&gt;
	 * If {@code null} value is provided, then custom {@link MessagePreparator}
	 * is disabled. Other configured preparators are used (using
	 * {@link #userData()}).
	 * &lt;/p&gt;
	 * 
	 * @param preparator
	 *            the custom preprator instance
	 * @return this instance for fluent chaining
	 * @see #userData()
	 */
	public CloudhopperBuilder messagePreparator(MessagePreparator preparator) {
<span class="nc" id="L1112">		this.preparator = preparator;</span>
<span class="nc" id="L1113">		return this;</span>
	}

	/**
	 * SMS message (named &quot;User Data&quot; in SMPP specification) can be transmitted
	 * using:
	 * &lt;ul&gt;
	 * &lt;li&gt;Either {@code short_message} field (standard field for &quot;User
	 * Data&quot;).&lt;/li&gt;
	 * &lt;li&gt;Or {@code message_payload} optional parameter.&lt;/li&gt;
	 * &lt;/ul&gt;
	 * 
	 * &lt;p&gt;
	 * This builder allow to configure which strategy to use for sending
	 * message:
	 * &lt;ul&gt;
	 * &lt;li&gt;Either use {@code short_message} field&lt;/li&gt;
	 * &lt;li&gt;Or use {@code message_payload} field&lt;/li&gt;
	 * &lt;/ul&gt;
	 * 
	 * &lt;p&gt;
	 * The result of {@link #userData()} configuration affects the message
	 * preparation strategy.
	 * &lt;/p&gt;
	 * 
	 * &lt;p&gt;
	 * Examples of usage:
	 * 
	 * &lt;pre&gt;
	 * {@code
	 * .userData()
	 *   .useShortMessage()
	 *     .properties(&quot;${ogham.sms.cloudhopper.user-data.use-short-message}&quot;, &quot;${ogham.sms.smpp.user-data.use-short-message}&quot;)
	 *     .defaultValue(true)
	 *     .and()
	 *   .useTlvMessagePayload()
	 *     .properties(&quot;${ogham.sms.cloudhopper.user-data.use-tlv-message-payload}&quot;, &quot;${ogham.sms.smpp.user-data.use-tlv-message-payload}&quot;)
	 *     .defaultValue(false)
	 * }
	 * &lt;/pre&gt;
	 * 
	 * If any of {@code ogham.sms.cloudhopper.user-data.use-short-message}
	 * property or {@code ogham.sms.user-data.use-short-message} property is set
	 * to true, it uses {@code short_message} field.
	 * 
	 * If any of {@code ogham.sms.cloudhopper.user-data.use-tlv-message-payload}
	 * property or {@code ogham.sms.user-data.use-tlv-message-payload} property
	 * is set to true, it uses {@code message_payload} field.
	 * 
	 * If none of the above properties is set, it uses {@code short_message}
	 * field is used (last value of {@code shortMessage} is set to
	 * {@code &quot;true&quot;}).
	 * 
	 * &lt;p&gt;
	 * If {@link #userData()} is not configured at all, then default behavior is
	 * used ({@code short_message} field is used).
	 * &lt;/p&gt;
	 * 
	 * @return the builder to configure how the &quot;User Data&quot; is sent
	 */
	public UserDataBuilder userData() {
<span class="fc bfc" id="L1174" title="All 2 branches covered.">		if (userDataBuilder == null) {</span>
<span class="fc" id="L1175">			userDataBuilder = new UserDataBuilder(this, buildContext);</span>
		}
<span class="fc" id="L1177">		return userDataBuilder;</span>
	}

	/**
	 * Data Coding Scheme is a one-octet field in Short Messages (SM) and Cell
	 * Broadcast Messages (CB) which carries a basic information how the
	 * recipient handset should process the received message. The information
	 * includes:
	 * &lt;ul&gt;
	 * &lt;li&gt;the character set or message coding which determines the encoding of
	 * the message user data&lt;/li&gt;
	 * &lt;li&gt;the message class which determines to which component of the Mobile
	 * Station (MS) or User Equipment (UE) should be the message delivered&lt;/li&gt;
	 * &lt;li&gt;the request to automatically delete the message after reading&lt;/li&gt;
	 * &lt;li&gt;the state of flags indicating presence of unread voicemail, fax,
	 * e-mail or other messages&lt;/li&gt;
	 * &lt;li&gt;the indication that the message content is compressed&lt;/li&gt;
	 * &lt;li&gt;the language of the cell broadcast message&lt;/li&gt;
	 * &lt;/ul&gt;
	 * The field is described in 3GPP 23.040 and 3GPP 23.038 under the name
	 * TP-DCS (see &lt;a href=
	 * &quot;https://en.wikipedia.org/wiki/Data_Coding_Scheme#SMS_Data_Coding_Scheme&quot;&gt;SMS
	 * Data Coding Scheme&lt;/a&gt;).
	 * 
	 * SMPP 3.4 introduced a new list of {@code data_coding} values (see
	 * &lt;a href=&quot;https://en.wikipedia.org/wiki/Short_Message_Peer-to-Peer&quot;&gt;Short
	 * Message Peer to Peer&lt;/a&gt;).
	 * 
	 * &lt;p&gt;
	 * This builder allows to configure how Data Coding Scheme value is
	 * determined:
	 * &lt;ul&gt;
	 * &lt;li&gt;Use automatic mode base on interface version (see
	 * {@link #interfaceVersion(InterfaceVersion)} and
	 * {@link #interfaceVersion(Byte)}) and charset encoding (see
	 * {@link #encoder()}) used to encode the message (&quot;User Data&quot;)&lt;/li&gt;
	 * &lt;li&gt;Use a fixed value used for every message&lt;/li&gt;
	 * &lt;li&gt;Use a custom implementation&lt;/li&gt;
	 * &lt;/ul&gt;
	 * 
	 * &lt;p&gt;
	 * Examples of usage:
	 * 
	 * &lt;pre&gt;
	 * {@code
	 * .dataCodingScheme()
	 *   .auto(&quot;${ogham.sms.cloudhopper.data-coding-scheme.auto.enable}&quot;, &quot;${ogham.sms.smpp.data-coding-scheme.auto.enable}&quot;)
	 *   .value(&quot;${ogham.sms.cloudhopper.data-coding-scheme.value}&quot;, &quot;${ogham.sms.smpp.data-coding-scheme.value}&quot;)
	 *   .custom(new MyCustomDataCodingProvider())
	 * }
	 * &lt;/pre&gt;
	 * 
	 * See {@link DataCodingSchemeBuilder#auto(Boolean)},
	 * {@link DataCodingSchemeBuilder#value(Byte)} and
	 * {@link DataCodingSchemeBuilder#custom(DataCodingProvider)} for more
	 * information.
	 * 
	 * 
	 * @return the builder to configure how to determine Data Coding Scheme
	 *         value
	 */
	public DataCodingSchemeBuilder dataCodingScheme() {
<span class="fc bfc" id="L1239" title="All 2 branches covered.">		if (dataCodingBuilder == null) {</span>
<span class="fc" id="L1240">			dataCodingBuilder = new DataCodingSchemeBuilder(this, buildContext, this::getInterfaceVersion);</span>
		}
<span class="fc" id="L1242">		return dataCodingBuilder;</span>
	}

	@Override
	public CloudhopperSMPPSender build() {
<span class="fc" id="L1247">		CloudhopperSessionOptions sessionOpts = buildSessionOpts();</span>
<span class="fc" id="L1248">		SmppSessionConfiguration session = buildSession(sessionOpts);</span>
<span class="fc bfc" id="L1249" title="All 4 branches covered.">		if (session.getHost() == null || session.getPort() == 0) {</span>
<span class="fc" id="L1250">			return null;</span>
		}
<span class="fc" id="L1252">		CloudhopperOptions options = buildOptions(sessionOpts);</span>
<span class="fc" id="L1253">		LOG.info(&quot;Sending SMS using Cloudhopper is registered&quot;);</span>
<span class="fc" id="L1254">		LOG.debug(&quot;SMPP server address: {}:{}&quot;, session.getHost(), session.getPort());</span>
<span class="fc" id="L1255">		return buildContext.register(new CloudhopperSMPPSender(session, options, buildPreparator(), buildClientSupplier(), buildSmppSessionHandler()));</span>
	}

	private CloudhopperSessionOptions buildSessionOpts() {
<span class="fc bfc" id="L1259" title="All 2 branches covered.">		if (sessionBuilder != null) {</span>
<span class="fc" id="L1260">			return sessionBuilder.build();</span>
		}
<span class="fc" id="L1262">		CloudhopperSessionOptions cloudhopperSessionOptions = buildContext.register(new CloudhopperSessionOptions());</span>
<span class="fc" id="L1263">		cloudhopperSessionOptions.setConnectRetry(noRetry());</span>
<span class="fc" id="L1264">		return cloudhopperSessionOptions;</span>
	}

	private SimpleRetryExecutor noRetry() {
<span class="fc" id="L1268">		return buildContext.register(new SimpleRetryExecutor(() -&gt; null, buildContext.register(new ThreadSleepAwaiter())));</span>
	}

	private MessagePreparator buildPreparator() {
<span class="pc bpc" id="L1272" title="1 of 2 branches missed.">		if (preparator != null) {</span>
<span class="nc" id="L1273">			return preparator;</span>
		}
<span class="fc bfc" id="L1275" title="All 2 branches covered.">		if (userDataBuilder != null) {</span>
<span class="fc" id="L1276">			UserDataPropValues values = userDataBuilder.build();</span>
<span class="fc bfc" id="L1277" title="All 2 branches covered.">			if (values.isUseShortMessage()) {</span>
<span class="fc" id="L1278">				return buildShortMessagePreparator();</span>
			}
<span class="pc bpc" id="L1280" title="1 of 2 branches missed.">			if (values.isUseTlvMessagePayload()) {</span>
<span class="fc" id="L1281">				return buildTlvMessagePayloadMessagePreparator();</span>
			}
		}
<span class="fc" id="L1284">		return buildShortMessagePreparator();</span>
	}

	private MessagePreparator buildShortMessagePreparator() {
<span class="fc" id="L1288">		return buildContext.register(new ShortMessagePreparator(buildSplitter(buildEncoder()), buildDataCodingProvider(), buildPhoneNumberTranslator()));</span>
	}

	private MessagePreparator buildTlvMessagePayloadMessagePreparator() {
<span class="fc" id="L1292">		return buildContext.register(new TlvMessagePayloadMessagePreparator(buildSplitter(buildEncoder()), buildDataCodingProvider(), buildPhoneNumberTranslator()));</span>
	}

	private Encoder buildEncoder() {
<span class="fc bfc" id="L1296" title="All 2 branches covered.">		if (encoderBuilder == null) {</span>
<span class="fc" id="L1297">			return buildContext.register(new CloudhopperCharsetSupportingEncoder(NamedCharset.from(NAME_GSM)));</span>
		}
<span class="fc" id="L1299">		return encoderBuilder.build();</span>
	}

	private DataCodingProvider buildDataCodingProvider() {
<span class="fc bfc" id="L1303" title="All 2 branches covered.">		if (dataCodingBuilder == null) {</span>
<span class="fc" id="L1304">			return buildContext.register(new CharsetMapToCharacterEncodingGroupDataCodingProvider(true));</span>
		}
<span class="fc" id="L1306">		return dataCodingBuilder.build();</span>
	}

	private MessageSplitter buildSplitter(Encoder encoder) {
<span class="fc bfc" id="L1310" title="All 2 branches covered.">		if (messageSplitterBuilder == null) {</span>
<span class="fc" id="L1311">			return buildContext.register(new NoSplitMessageSplitter(encoder));</span>
		}
<span class="fc" id="L1313">		MessageSplitter splitter = messageSplitterBuilder.build();</span>
<span class="fc bfc" id="L1314" title="All 2 branches covered.">		if (splitter != null) {</span>
<span class="fc" id="L1315">			return splitter;</span>
		}
<span class="fc" id="L1317">		return buildContext.register(new NoSplitMessageSplitter(encoder));</span>
	}

	private SmppClientSupplier buildClientSupplier() {
<span class="fc bfc" id="L1321" title="All 2 branches covered.">		if (clientSupplier == null) {</span>
<span class="fc" id="L1322">			return buildContext.register(DefaultSmppClient::new);</span>
		}
<span class="fc" id="L1324">		return clientSupplier;</span>
	}

	private SmppSessionHandlerSupplier buildSmppSessionHandler() {
<span class="fc bfc" id="L1328" title="All 2 branches covered.">		if (smppSessionHandler == null) {</span>
<span class="fc" id="L1329">			return () -&gt; null;</span>
		}
<span class="fc" id="L1331">		return smppSessionHandler;</span>
	}

	private PhoneNumberTranslator buildPhoneNumberTranslator() {
		// TODO: allow configuration of fallback phone number translator
<span class="fc" id="L1336">		return buildContext.register(new CompositePhoneNumberTranslator(buildContext.register(new DefaultHandler())));</span>
	}

	private SmppSessionConfiguration buildSession(CloudhopperSessionOptions sessionOpts) {
<span class="fc bfc" id="L1340" title="All 2 branches covered.">		if (sessionConfiguration != null) {</span>
<span class="fc" id="L1341">			return sessionConfiguration;</span>
		}
<span class="fc" id="L1343">		SmppSessionConfiguration session = buildContext.register(new SmppSessionConfiguration(buildBindType(), systemIdValueBuilder.getValue(), passwordValueBuilder.getValue()));</span>
<span class="fc" id="L1344">		session.setHost(getHost());</span>
<span class="fc" id="L1345">		session.setPort(getPort());</span>
<span class="fc" id="L1346">		session.setSystemType(systemTypeValueBuilder.getValue());</span>
<span class="fc" id="L1347">		set(session::setBindTimeout, sessionOpts::getBindTimeout);</span>
<span class="fc" id="L1348">		set(session::setConnectTimeout, sessionOpts::getConnectTimeout);</span>
<span class="fc" id="L1349">		session.setInterfaceVersion(getInterfaceVersion());</span>
<span class="fc" id="L1350">		set(session::setName, sessionOpts::getSessionName);</span>
<span class="fc" id="L1351">		set(session::setRequestExpiryTimeout, sessionOpts::getRequestExpiryTimeout);</span>
<span class="fc" id="L1352">		set(session::setWindowMonitorInterval, sessionOpts::getWindowMonitorInterval);</span>
<span class="fc" id="L1353">		set(session::setWindowSize, sessionOpts::getWindowSize);</span>
<span class="fc" id="L1354">		set(session::setWindowWaitTimeout, sessionOpts::getWindowWaitTimeout);</span>
<span class="fc" id="L1355">		set(session::setWriteTimeout, sessionOpts::getWriteTimeout);</span>
<span class="fc" id="L1356">		session.setAddressRange(addressRange);</span>
<span class="fc" id="L1357">		configureSsl(session);</span>
<span class="fc" id="L1358">		configureLogs(session);</span>
<span class="fc" id="L1359">		return session;</span>
	}

	private static &lt;T&gt; void set(Consumer&lt;T&gt; setter, Supplier&lt;T&gt; getter) {
<span class="fc" id="L1363">		T value = getter.get();</span>
<span class="fc bfc" id="L1364" title="All 2 branches covered.">		if (value != null) {</span>
<span class="fc" id="L1365">			setter.accept(value);</span>
		}
<span class="fc" id="L1367">	}</span>

	private void configureLogs(SmppSessionConfiguration session) {
<span class="pc bpc" id="L1370" title="1 of 2 branches missed.">		if (loggingBuilder == null) {</span>
<span class="fc" id="L1371">			return;</span>
		}
<span class="nc" id="L1373">		LoggingOptions options = loggingBuilder.build();</span>
<span class="nc bnc" id="L1374" title="All 2 branches missed.">		if (options != null) {</span>
<span class="nc" id="L1375">			session.setLoggingOptions(options);</span>
		}
<span class="nc" id="L1377">	}</span>

	private void configureSsl(SmppSessionConfiguration session) {
<span class="pc bpc" id="L1380" title="1 of 2 branches missed.">		if (sslBuilder == null) {</span>
<span class="fc" id="L1381">			return;</span>
		}
<span class="nc" id="L1383">		SslConfiguration sslConfiguration = sslBuilder.build();</span>
<span class="nc bnc" id="L1384" title="All 2 branches missed.">		session.setUseSsl(sslConfiguration != null);</span>
<span class="nc bnc" id="L1385" title="All 2 branches missed.">		if (sslConfiguration != null) {</span>
<span class="nc" id="L1386">			session.setSslConfiguration(sslConfiguration);</span>
		}
<span class="nc" id="L1388">	}</span>

	private SmppBindType buildBindType() {
<span class="fc" id="L1391">		return bindTypeValueBuilder.getValue(TRANSMITTER);</span>
	}

	private Byte getInterfaceVersion() {
<span class="fc" id="L1395">		InterfaceVersion version = interfaceVersionValueBuilder.getValue(VERSION_3_4);</span>
<span class="fc" id="L1396">		return version.value();</span>
	}

	private int getPort() {
<span class="fc" id="L1400">		return portValueBuilder.getValue(0);</span>
	}

	private String getHost() {
<span class="fc" id="L1404">		return hostValueBuilder.getValue();</span>
	}

	private CloudhopperOptions buildOptions(CloudhopperSessionOptions sessionOpts) {
<span class="fc bfc" id="L1408" title="All 2 branches covered.">		Long responseTimeout = sessionOpts.getResponseTimeout() == null ? DEFAULT_RESPONSE_TIMEOUT : sessionOpts.getResponseTimeout();</span>
<span class="fc bfc" id="L1409" title="All 2 branches covered.">		Long unbindTimeout = sessionOpts.getUnbindTimeout() == null ? DEFAULT_UNBIND_TIMEOUT : sessionOpts.getUnbindTimeout();</span>
<span class="fc" id="L1410">		RetryExecutor connectRetry = sessionOpts.getConnectRetry();</span>
<span class="fc" id="L1411">		return buildContext.register(new CloudhopperOptions(responseTimeout, unbindTimeout, connectRetry, sessionOpts.isKeepSession()));</span>
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.4.201905082037</span></div></body></html>